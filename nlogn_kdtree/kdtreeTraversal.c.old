#include <stdio.h>
//#include <malloc.h>
#include <stdlib.h>
//#include <math.h>
#include "rgs/rayGen.h"
#include "rgs/shading.h"
#include "misc/dump.h"
#include "tree/kdtreeTraversal.h"
#include "tree/RayTriangleIT.h"
#include <windows.h>


//#define variable 8
extern FILE *mem_addr;
FILE *getfile;

#define swap(a,b) {float t;t=a;a=b;b=t;}
extern KdAccelNode *ext_kd_node; 
//extern BvhNode *pBvhDfl;
//extern BvhNode *pBvhBfl;
extern int32 *ipObjectIds;
extern uint32 uiFrame;
extern int32 iTotalNumTrv;
extern int32 iTotalNumIst;
extern int32 iTotalNumBVHbuild;
extern int32 iTotalNumRays;
extern int32 iTotalNumNodes;
int height=0;
int width=0;

 extern FILE *primcompute;
int prim[500000];

//midstart trail
//#define midstart_trail 0

int32 currentMidPtr;
int32 savelevel[STACK_SIZE];
int32 shift_level;
int *visable_test;
int32 mid_level;
int32 save_cnt;
//testing

/* Legacy Code
#ifdef RESTART_TRAIL

#define STACK_SIZE 8 // Size of the traversal stack in local memory.
*/
void Intersect(Scene *pScene,KdTreeAccel kd_accel, Ray ray,Hit *hit, int iAnyHit)  {
   // PBRT_KDTREE_INTERSECTION_TEST(const_cast<KdTreeAccel *>(this), const_cast<Ray *>(&ray));
    // Compute initial parametric range of ray inside kd-tree extent
   #define MAX_TODO 64
    KdToDo todo[MAX_TODO];
    float tmin, tmax;
    // float invDir[3];
     int todoPos = 0;
       float32 faUv[2];
    float32  fT;
     float32   fHitT;
    // Traverse kd-tree nodes in order for ray
    bool b_hit = false;
    bool move_to_abovechild=0;
    int current=0;
    KdAccelNode *node = &kd_accel.nodes[0];
    unsigned int count=0;
    float32 fMinT;
    fMinT = ray.fMinimumT;

    if (!box_IntersectP(kd_accel.bounds,ray, &tmin, &tmax))
    {
        //PBRT_KDTREE_RAY_MISSED_BOUNDS();
        return ;
    }
     fHitT     = ray.fMaximumT;
     fT = fHitT;
    // Prepare to traverse kd-tree for ray
   
    /*invDir[0]=1.f/ray.faDir[0];
    invDir[1]=1.f/ray.faDir[1];
    invDir[2]=1.f/ray.faDir[2];*/

    /*if(ray.iScreenX==355 && ray.iScreenY == 133)
            {
                printf("enter");
                getchar();
            }*/

    
    while (node != NULL) {
        count++;
        // Bail out if we found a hit closer than the current node
        if (ray.fMaximumT < tmin) break;
        if (node->flags<3) {
            //PBRT_KDTREE_INTERSECTION_TRAVERSED_INTERIOR_NODE(const_cast<KdAccelNode *>(node));
            // Process kd-tree interior node
             KdAccelNode *firstChild;
              KdAccelNode *secondChild;
            // Compute parametric distance along ray to split plane
            int axis = node->flags;
            float tplane = (node->split - ray.faOri[axis]) * ray.faInvDir[axis];

            // Get node children pointers for ray
           
            int belowFirst = (ray.faOri[axis] <  node->split) ||
                             (ray.faOri[axis] == node->split && ray.faDir[axis] <= 0);
            if (belowFirst) {
                
                firstChild=node+1;
                    secondChild = &kd_accel.nodes[node->aboveChild];
                
            }
            else {
                firstChild = &kd_accel.nodes[node->aboveChild];
                secondChild=node+1;
                
                
            }
            
            // Advance to next child node, possibly enqueue other child
            if (tplane > tmax || tplane <= 0)
            {
                
                node = firstChild;
                
            }
            else if (tplane < tmin){
             
                
                node = secondChild;
                
        
            }
            else {
                
                

                 todo[todoPos].node = secondChild;
                todo[todoPos].tmin = tplane;
                todo[todoPos].tmax = tmax;
                todoPos++;
                
                // Enqueue _secondChild_ in todo list
              
                node = firstChild;
                tmax = tplane;
                
            }
        }
        else {
            //PBRT_KDTREE_INTERSECTION_TRAVERSED_LEAF_NODE(const_cast<KdAccelNode *>(node), node->nPrimitives());
            // Check for intersections inside leaf node
            unsigned int nPrimitives = node->nPrims;
            if (nPrimitives == 1) {
                /*if(ray.iScreenX==355 && ray.iScreenY == 133&&node->onePrimitive==93041)
                     {
                         printf("enter");
                           getchar();
                     }*/
                //Primitive prim = kd_accel.primitives[node->onePrimitive];
                //fprintf(getfile,"tri_address: %d\n",node->onePrimitive);
                visable_test[node->onePrimitive]=1;
                if (TriIntersectWald (&ray, &pScene->pPrimsWald[node->onePrimitive],
                                                     faUv, &fT) != -1)

                                {
                                    
                                    if (iAnyHit == 1)/* Closest intersection not required => terminate.*/
                                    {
                                        hit->iPrimIndex = node->onePrimitive;
                                        return;                                
                                    }

                                      if (fHitT > fT && fMinT < fT)
                                    {  
                                        
                                        ray.fMaximumT = fT;
                                        hit->fHitT = fT;
                                        hit->fHitU = faUv[0];
                                        hit->fHitV = faUv[1];
                                        hit->iPrimIndex = node->onePrimitive;
                                        fHitT=fT;                                
                                    }                      
                                   
                                }
            }
            else {
                unsigned int i;
             
                for ( i = 0; i < nPrimitives; i++) {
                    //Primitive prim = kd_accel.primitives[node->primitives[i]];
                    //fprintf(getfile,"tri_address: %d\n",node->primitives[i]);
                     /*if( ray.iScreenX==355 && ray.iScreenY == 133&&node->primitives[i]==93041)
                     {
                         printf("enter");
                           getchar();
                     }*/
                    
                                 //visable_test[node->primitives[i]]=1;
                    if (TriIntersectWald (&ray, &pScene->pPrimsWald[node->primitives[i]],
                                                     faUv, &fT) != -1)

                                {
                                    
                                    if (iAnyHit == 1)/* Closest intersection not required => terminate.*/
                                    {
                                        hit->iPrimIndex = node->primitives[i];
                                        return;                                
                                    }

                                                                
                                        if (fHitT > fT && fMinT < fT)
                                    {   
                                        
                                        ray.fMaximumT = fT;
                                        hit->fHitT = fT;
                                        hit->fHitU = faUv[0];
                                        hit->fHitV = faUv[1];
                                        hit->iPrimIndex = node->primitives[i];
                                        fHitT=fT;                                
                                    }                         
                                   
                                }


                    // Check one primitive inside leaf node
                    //PBRT_KDTREE_INTERSECTION_PRIMITIVE_TEST(const_cast<Primitive *>(prim.GetPtr()));
                    //if (prim->Intersect(ray, isect))
                    //{
                    //    //PBRT_KDTREE_INTERSECTION_HIT(const_cast<Primitive *>(prim.GetPtr()));
                    //    b_hit = true;
                    //}
                }
            }

            // Grab next node to process from todo list
            if (todoPos > 0) {
                todoPos--;
                node = todo[todoPos].node;
                tmin = todo[todoPos].tmin;
                tmax = todo[todoPos].tmax;
                
            }
            else
                break;
        }
    }
    //PBRT_KDTREE_INTERSECTION_FINISHED();
    return ;
}


void kd_Rendering(Scene *pScene, Shader *pShader, Config *pConfig)
{
    /*ray traversal*/
    int32 h, w, sy, sx, iRayI;
    float32 fAaX, aa_y, fAaXIncrease, fAaYIncrease;
    uint32 uipNumTrv = 0;
    uint32 upiNumIst = 0;
    uint32 uiNumRays = pConfig->uiScreenResolutionX * 
                       pConfig->uiScreenResolutionY * pConfig->uiSampleX *
                       pConfig->uiSampleY;
    uint32 uiNumSamples = pConfig->uiSampleX * pConfig->uiSampleY;
    Ray *pAray;

    printf("start rendering..");
    //spfile = fopen("minwoo_test.txt","w");
    
        pScene->pCamera->iResolutionX = pConfig->uiScreenResolutionX;
        pScene->pCamera->iResolutionY = pConfig->uiScreenResolutionY;
        //pScene->pCamera.fFovAngle = 70.0f;
        
        SetCamera(pScene->pCamera);
        
        pAray = (Ray*) malloc(sizeof(Ray) * (uiNumRays));



        iRayI = 1;
        fAaXIncrease = 1/(float32)pConfig->uiSampleX;
        fAaYIncrease = 1/(float32)pConfig->uiSampleY;

        for (h = pScene->pCamera->iResolutionY-1; h >= 0; h--)
        {
            for (w = pScene->pCamera->iResolutionX - 1; w >= 0; w--)
            {    
                for (sy = 0, aa_y = 0.0; sy < pConfig->uiSampleY;
                    aa_y += fAaYIncrease, sy++)  /*antialiasing Y-samples*/
                { 
                    for (sx = 0, fAaX = 0.0; sx < pConfig->uiSampleX;
                        fAaX += fAaXIncrease, sx++)  /*antialiasing X-samples*/
                    { 
                        pAray[(uiNumRays) - iRayI] = GetFirstRay(w, h, fAaX, aa_y);
                        iRayI += 1;
                    }
                }
            }
        }
        
        iRayI = 1;
        for (h = pScene->pCamera->iResolutionY - 1; h >= 0; h--)
        {
        
            for (w = pScene->pCamera->iResolutionX - 1; w >= 0; w--)
            {                
                Ray ray;
                float32 faMixedColor[3];
                faMixedColor[0] = 0.0f;
                faMixedColor[1] = 0.0f;
                faMixedColor[2] = 0.0f;
                
                    
            
                for (sy = 0; sy < pConfig->uiSampleY; sy++)  /*antialiasing Y-samples*/
                { 
                    for (sx = 0; sx < pConfig->uiSampleX; sx++)  /*antialiasing X-samples*/
                    { 
                        float32 faOutColor[3] = {0};
                        Hit hit;
                        ray = pAray[(uiNumRays) - iRayI];
                        iRayI += 1;

                        hit.fHitT = -1;
                        hit.fHitU = 0;
                        hit.fHitV = 0;
                        hit.iPrimIndex = -1;

                        /*traverse tree with primary ray*/
                        Intersect(pScene, pScene->kd_accelerator, ray,&hit,0);

                        /*if(hit.iPrimIndex==-1)
                        {
                            printf("nointersect %d, %d",ray.iScreenX,ray.iScreenY);
                            getchar();*/
                        //}
                        /*shading*/
                        Shading(faOutColor, pScene, ray, hit, pShader,
                                pConfig);

                        /*antialiasing*/
                        SuperSampling(faMixedColor, faOutColor,
                                        ((sx+1)*(sy+1) == uiNumSamples), 
                                        uiNumSamples);
                    }
                }

                /*update framebuffer*/
                UpdateFrameBuffer(pShader, faMixedColor, ray.iScreenX, 
                                    ray.iScreenY);
            }
        }

    iTotalNumTrv += uipNumTrv;
    iTotalNumIst += upiNumIst;
    iTotalNumRays += uiNumRays;
    printf ("%d uiFrame, Num of TRV/IST per ray : %.2f %.2f\n", uiFrame, 
            uipNumTrv / (float32)uiNumRays, upiNumIst / (float32)uiNumRays);
    //printf("TEST change address count : %d\n",cnt_test); 
    //fclose(spfile);
    if (pAray != NULL) free(pAray);

    if (uiFrame%PRINT_BMP_PERIOD == 0)
    {
        int8 caFileName[128] = "ferrari_0.bmp";
        //sprintf_s(caFileName, 128, "%s.%d.bmp", pConfig->caRenderFile, uiFrame);
        //sprintf(caFileName, 128, "%s.%d.bmp", pConfig->caRenderFile, uiFrame);
        OutputFrameBuffer(pShader, caFileName);
    }

#if 0 /*ASYNC_BUILD*/
    if (rebuild_frame > REBUILD_PERIOD)
    {            
        _ObjLoader.ReadData(fTime - fTick*ceilf(rebuild_frame-1), &pScene);    
        CalculateAabb(pScene->obj_bounds, &pScene->scene_bounds, 
                        pScene->pPrims, pScene->uiNumPrims);

#if PRINT_TREE_BUILD_STATS 
        LARGE_INTEGER start,end, liFrequency;
        printf ("BVH build start\n");
        QueryPerformanceFrequency(&liFrequency); /*시간 측정 초기화*/
        QueryPerformanceCounter(&start); /*시간 시작 측정*/
#endif
        BvhInit(pBvhDfl, pScene->obj_bounds, &pScene->scene_bounds, 
                pScene->uiNumPrims, ipObjectIds);
        Build(pBvhDfl, pScene->obj_bounds, 0, 0, pScene->uiNumPrims, 
                ipObjectIds);    
        ConvertBfl(pBvhDfl, pBvhBfl);

#if PRINT_TREE_BUILD_STATS 
        QueryPerformanceCounter(&end); /*시간 측정 완료*/
        printf ("BVH build end\n");        
        printBVHStatus();
        printf("build time : %lfs\n", (float64)(end.QuadPart - 
                start.QuadPart) / (float64)liFrequency.QuadPart);
#endif    
        iTotalNumNodes += getNumBVHNodes();
        iTotalNumBVHbuild++;

        rebuild_frame -= REBUILD_PERIOD;
    }
    //rebuild_frame ++;
#endif

    printf("done\n");
}


typedef struct {
    Ray ray;
    Hit hit;
} kd_ShaderJob;


Ray aGRayQ[100];
kd_ShaderJob aGJobQ[100];

int32 kd_iGiRayJobNum = 0;
int32 kd_iGiShaderJobNum = 0;
float32 *fpGpFb;
int32 iGiX, iGiY;


void kd_RayQEnqueue(Ray ray) {
    aGRayQ[kd_iGiRayJobNum++] = ray;
}


void kd_ShadeQEnqueue(Ray ray, Hit hit) {
    aGJobQ[kd_iGiShaderJobNum].ray = ray;
    aGJobQ[kd_iGiShaderJobNum].hit = hit;
    kd_iGiShaderJobNum++;
}


void kd_AddPixelColor(int32 iX, int32 iY, float32 *fOutColor) {

    fOutColor[0] += fpGpFb[iY * iGiX * 3 + 3 * iX];
    fpGpFb[iY * iGiX * 3 + 3 * iX] = SAIT_CLAMP(fOutColor[0], 0, 1);

    fOutColor[1] += fpGpFb[iY*iGiX*3 + 3*iX + 1];
    fpGpFb[iY * iGiX * 3 + 3 * iX + 1] = SAIT_CLAMP(fOutColor[1], 0, 1);

    fOutColor[2] += fpGpFb[iY*iGiX*3 + 3*iX + 2];
    fpGpFb[iY * iGiX * 3 + 3 * iX + 2] = SAIT_CLAMP(fOutColor[2], 0, 1);
}



void kd_RenderingStream(Scene *pScene, Shader *pShader, Config *pConfig)
{
    /*ray traversal*/
    int32 h, w, sy, sx, ray_i;
    float32 fAaX, fAaY, fAaXIncrease, fAaYIncrease;
    uint32 uipNumTrv = 0;
    uint32 upiNumIst = 0;
    uint32 uiNumRays = pConfig->uiScreenResolutionX * 
                       pConfig->uiScreenResolutionY *
                       pConfig->uiSampleX * pConfig->uiSampleY;
    uint32 uiNumSamples = pConfig->uiSampleX * pConfig->uiSampleY;
    Ray *aRay;

    int i; //test
    LARGE_INTEGER start,end, liFrequency;

    char *get_camerafile;
    iGiX = pConfig->uiScreenResolutionX;
    iGiY = pConfig->uiScreenResolutionY;
    fpGpFb = (float32 *)malloc(sizeof(float32) * 3 * iGiX * iGiY);
    memset(fpGpFb, 0, sizeof(float32)*3*iGiX*iGiY);

  
    if (PRINT_TREE_BUILD_STATS == 1)
        {
            printf("start rendering..");
            QueryPerformanceFrequency(&liFrequency); /*시간 측정 초기화*/
            QueryPerformanceCounter(&start); /*시간 시작 측정*/
        }

   getfile=fopen("tri_address_get.txt","w");       
    pScene->pCamera->iResolutionX = pConfig->uiScreenResolutionX;
    pScene->pCamera->iResolutionY = pConfig->uiScreenResolutionY;
    //pScene->pCamera.fFovAngle = 70.0f;
    SetCamera(pScene->pCamera);

    aRay = (Ray*) malloc(sizeof(Ray) * (uiNumRays));

    //test용
    visable_test=(int*)malloc(sizeof(int)*pScene->uiNumPrims);
    memset(visable_test,0,sizeof(int)*pScene->uiNumPrims);

    ray_i = 1;
    fAaXIncrease = 1/(float32)pConfig->uiSampleX;
    fAaYIncrease = 1/(float32)pConfig->uiSampleY;
    //get_camerafile="ytIa02G35kz1i:ZZ/0//iSay/5W6Ex19///c/05frY109Qx7w////m100"; //sibenik camera signature
    //get_camerafile="cIxMx/sK/Ty/EFu3z/5m9mWx/YPA5z/8///m007toC10AnAHx///Uy200";   //fairyforest camera signature
    get_camerafile="kQ2ox/Ezo200djN4/04LEMJy15u0bu/80//m007toC10AnAHx///Uy200"; //fairyforest camera signature
    setCameraBySignature(get_camerafile, pScene->pCamera->iResolutionX ,pScene->pCamera->iResolutionY);
    for (h = pScene->pCamera->iResolutionY - 1; h >= 0; h--)
    {
        for (w = pScene->pCamera->iResolutionX - 1; w >= 0; w--)
        {    
            for (sy = 0, fAaY = 0.0; sy < pConfig->uiSampleY;
                fAaY += fAaYIncrease, sy++)  /*antialiasing Y-samples*/
            { 
                for (sx = 0, fAaX = 0.0; sx < pConfig->uiSampleX;
                    fAaX += fAaXIncrease, sx++)  /*antialiasing X-samples*/
                { 
                    //aRay[(uiNumRays) - ray_i] = GetFirstRay_stream(w, h, fAaX, fAaY, uiNumSamples);
                    aRay[(uiNumRays) - ray_i] = GetFirstRayBySignature(w, h, fAaX, fAaY, uiNumSamples);
                    ray_i += 1;
                }
            }
        }
    }

    ray_i = 1;
    for (h = pScene->pCamera->iResolutionY - 1; h >= 0; h--)
    {
        for (w = pScene->pCamera->iResolutionX - 1; w >= 0; w--)
        {                
            Ray ray;
            float32 faMixedColor[3];
            faMixedColor[0] = 0.0f;
            faMixedColor[1] = 0.0f;
            faMixedColor[2] = 0.0f;
            // printf(">>>>> x,y %d %d\n",w,h);

            for (sy = 0; sy < pConfig->uiSampleY; sy++)  /*antialiasing Y-samples*/
            { 
                for (sx = 0; sx < pConfig->uiSampleX; sx++)  /*antialiasing X-samples*/
                { 
                    float32 faOutcolor[3] = {0};
                    Hit hit;
                    int32 i;

                    ray = aRay[(uiNumRays) - ray_i];
                    ray_i += 1;


                    //aGRayQ[iGiRayJobNum++] = ray;
                    kd_RayQEnqueue(ray);
                    
                    while (kd_iGiRayJobNum > 0) {
//                        printf("ray q %d\n", iGiRayJobNum);
                        for (i = 0; i < kd_iGiRayJobNum; i++) {

                            hit.fHitT = -1;
                            hit.fHitU = 0;
                            hit.fHitV = 0;
                            hit.iPrimIndex = -1;
                            /*traverse tree with primary ray*/
                            Intersect(pScene, pScene->kd_accelerator, aGRayQ[i],&hit,0);
                            /* aGJobQ[iGiShaderJobNum].ray = aGRayQ[i];
                            aGJobQ[iGiShaderJobNum++].hit =  hit;
                            */
                            
                            kd_ShadeQEnqueue(aGRayQ[i], hit);
                            
                       }
                      kd_iGiRayJobNum = 0;

//                       printf("job q %d\n", iGiShaderJobNum);
                       for (i = 0; i < kd_iGiShaderJobNum; i++) {
                            ShadingStream(pScene, aGJobQ[i].ray, aGJobQ[i].hit,
                                          pConfig);
                       }
                       kd_iGiShaderJobNum = 0;
                    }
                }
            }

            
        }
    }

    for (h = 0;h < iGiY;h++) {
        for (w = 0;w < iGiX;w++) {
            /*update framebuffer*/
            UpdateFrameBuffer(pShader, fpGpFb+(h*iGiX*3 + 3*w), w, h);
        }
    }
    {
        int test=0;
        for(i=0;i<pScene->uiNumPrims;i++)
        {
                if(visable_test[i]==1)
                    test++;
        }
        printf("전체 프리미티브 갯수 : %d visable한 프리미티브 갯수 : %d 전체 비율 : %.2f %%",pScene->uiNumPrims,test,((float)test/(float)pScene->uiNumPrims)*100.f);
        //getchar();
    }
    iTotalNumTrv += uipNumTrv;
    iTotalNumIst += upiNumIst;
    iTotalNumRays += uiNumRays;
    printf ("%d uiFrame, Num of TRV/IST per ray : %.2f %.2f\n", uiFrame,
            uipNumTrv / (float32)uiNumRays, upiNumIst / (float32)uiNumRays);

    if (aRay != NULL) free(aRay);

    if (uiFrame%PRINT_BMP_PERIOD == 0)
    {
        int8 caFileName[128] = "ferrari_0.bmp";
        //sprintf_s(caFileName, 128, "%s.%d.bmp", pConfig->caRenderFile, uiFrame);
        OutputFrameBuffer(pShader, caFileName);
    }

#if 0 /*ASYNC_BUILD*/
    if (rebuild_frame > REBUILD_PERIOD)
    {            
        _ObjLoader.ReadData(fTime - fTick*ceilf(rebuild_frame-1), &pScene);    
        CalculateAabb(pScene->obj_bounds, &pScene->scene_bounds, 
                        pScene->pPrims, pScene->uiNumPrims);

#if PRINT_TREE_BUILD_STATS 
        LARGE_INTEGER start,end, liFrequency;
        printf ("BVH build start\n");
        QueryPerformanceFrequency(&liFrequency); /*시간 측정 초기화*/
        QueryPerformanceCounter(&start); /*시간 시작 측정*/
#endif
        BvhInit(pBvhDfl, pScene->obj_bounds, &pScene->scene_bounds, 
                pScene->uiNumPrims, ipObjectIds);
        Build(pBvhDfl, pScene->obj_bounds, 0, 0, pScene->uiNumPrims, 
                ipObjectIds);    
        ConvertBfl(pBvhDfl, pBvhBfl);

#if PRINT_TREE_BUILD_STATS 
        QueryPerformanceCounter(&end); /*시간 측정 완료*/
        printf ("BVH build end\n");        
        printBVHStatus();
        printf("build time : %lfs\n",
                (float64)(end.QuadPart - start.QuadPart) / 
                (float64)liFrequency.QuadPart);
#endif    
        iTotalNumNodes += getNumBVHNodes();
        iTotalNumBVHbuild++;

        rebuild_frame -= REBUILD_PERIOD;
    }
    //rebuild_frame ++;
#endif
    if (PRINT_TREE_BUILD_STATS == 1)
        {
            QueryPerformanceCounter(&end); /*시간 측정 완료*/
            printf ("done\n");        
                     printf("render time : %lfs\n", 
                    (float64)(end.QuadPart - start.QuadPart) / 
                    (float64)liFrequency.QuadPart);
        }
    fclose(getfile);
   
}