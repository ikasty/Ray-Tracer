
/*
    pbrt source code Copyright(c) 1998-2012 Matt Pharr and Greg Humphreys.

    This file is part of pbrt.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

    - Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    - Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 */
#ifndef PBRT_ACCELERATORS_KDTREEACCEL_H
#define PBRT_ACCELERATORS_KDTREEACCEL_H

#include <stdio.h>
#include "common/Triangle.h"
#include "misc/config.h"
#include "common/scene.h"
#include <stdlib.h>
#include <string.h>

//#if defined(_MSC_VER)
//#pragma once
//#endif
//


// accelerators/kdtreeaccel.h*
//#include "pbrt.h"
//#include "primitive.h"

// KdTreeAccel Declarations
#define Assert(expr) ((void)0)

typedef enum edge_type{ START = 3, PLANAR = 2,MID=1, END = 0 }edge_type; 
typedef enum side_type{ LEFT = 1, RIGHT = 0}side_type; 

typedef struct  {
    // BoundEdge Public Methods
   
   edge_type e_type;
   
    float t;
	float other_t;
    int primNum;
	
    int axis;
}BoundEdge;

typedef struct  {
    // BoundEdge Public Methods
 
   edge_type e_type;
   
    float t;
    int primNum;
	
    int axis;
	
}OBJBoundEdge;

typedef struct  {
    int depth;
    
	int current;
}test;


typedef struct  {
     KdAccelNode* node;
    float tmin, tmax;
	int current;
}KdToDo;


BBox ObjectBound(Triangle mesh);
int Round2Int(float val);
 int Log2Int(float v);

void CreateKdTreeAccelerator(Scene* scene );
void initLeaf(KdAccelNode* kd_node,unsigned int *primNums, int np);
/*#endif*/ // PBRT_ACCELERATORS_KDTREEACCEL_H
   // KdTreeAccel Public Methods

KdTreeAccel func_KdTreeAccel(int iObjBegin,int iObjEnd, 
        int icost, int tcost,unsigned int max_nodenum, float ebonus, int maxp,
        int md,Scene* scene);

	
	
	//void Intersect(BBox b_box,KdTreeAccel kd_accel, Ray ray,Hit *hit) ;
	bool IntersectP(BBox b_box, Ray ray,KdTreeAccel kd_accel) ;

//pbrt kdtree
void buildTree(KdTreeAccel *kd_accel,int nodeNum, BBox nodeBounds,
        BBox *allPrimBounds, unsigned int *primNums,
    unsigned int nPrimitives, int depth, BoundEdge *edges[3],
    unsigned int *prims0, unsigned int *prims1, int badRefines);


//nlog^2n kdtree
void sweep_buildTree(KdTreeAccel *kd_accel,int nodeNum, BBox nodeBounds,
         BBox *allPrimBounds, unsigned int *primNums,
        unsigned int nPrimitives, int depth, BoundEdge *edges[3],
        unsigned int *prims0, unsigned int *prims1, int badRefines);

void nlogn_buildTree(KdTreeAccel *kd_accel,int nodeNum, BBox nodeBounds,
         BBox *allPrimBounds, unsigned int *primNums,
        unsigned int nPrimitives, int depth, BoundEdge *edges,
        unsigned int *prims0, unsigned int *prims1,int num_event, int badRefines);

	BBox WorldBound(KdTreeAccel kd_accel);
bool CanIntersect() ;
float SplitPos(KdAccelNode *kd_node) ;
unsigned int func_nPrimitives(KdAccelNode *kd_node) ;
unsigned int SplitAxis(KdAccelNode *kd_node) ;
bool IsLeaf(KdAccelNode *kd_node) ;
unsigned int AboveChild(KdAccelNode *kd_node) ;

  
BBox Union_2(BBox bbox,BBox bbox2);   
void merge(BoundEdge* result,BoundEdge* event1,BoundEdge* event2,int nevent1,int nevent2);
int compareedge(const void *vpPa, const void *vpPb);   
void initInterior(KdAccelNode* kd_node,unsigned int axis, unsigned int ac, float s);
int nlogn_compareedge(const void *vpPa, const void *vpPb);
	
	void FullyRefine(KdTreeAccel* kd_accel, Primitive p);
float32 kd_ComputeArea(float32 fpabox[2][3]);
	 bool box_IntersectP(BBox b_box, Ray ray, float *hitt0,
                      float *hitt1);

#endif